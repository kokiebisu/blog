---
title: 48 - Rotate Image
photographer: Яна Гурская
coverImg: https://kocoblo-static.s3.amazonaws.com/leetcode/algorithms/matrix/48/cover-img.jpg
date: 2020/06/01
---

!(Example 1)[]

図だけを参照すると以下の考察ができます
１　実際に変わるのは真ん中以外の数字であること
２　そのまま要素の位置をずらそうと思うと、その置き換わる数字を記録しておかないといけないのでかなり効率が悪そうです。

では図ではなくコードでは以下のようになります

```js
input = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]
output = [
  [7, 4, 1],
  [8, 5, 2],
  [9, 6, 3],
]
```

ここで一つ気づいたポイントとして
１　それぞれの index の数字が逆向きで並べられて一つになっていると言うこと。
今回で言うと、
まずそれぞれの配列の index = 1 を集めると

```
1, 4, 7
```

となります。
これらを逆に並べて

```js
7, 4, 1
```

見比べてみるとこれは output の一つ目の要素に値します。
つまりこの作業を繰り返していけば答えに近づけるのではないでしょうか？

しかし、先ほども書いたように配列の中の要素の位置を入れ替えるのは大変扱いが難しいですし非効率です。

#### 配列の中身を一度全てバラけさせるのはどうか？

```js
[[1, 2, 3], [4, 5, 6], [7, 8, 9]] -> [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

このようにした上でそれぞれの要素の順番を３で割ったあまりで区別できるのではないでしょうか？

例えば
1 と言う数字は 1 % 3 = 1
4 と言う数字は 1 % 3 = 1
7...
このように分けられるのではないでしょうか？
